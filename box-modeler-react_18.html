<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Box Modeler - React</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #root {
            width: 100vw;
            height: 100vh;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            overflow-x: hidden;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        input[type="range"] {
            width: 200px;
        }
        input[type="number"] {
            width: 70px;
            padding: 4px;
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: right;
        }
        #download-btn {
            width: 100%;
            padding: 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }
        #download-btn:hover {
            background: #357abd;
        }
        #download-btn:active {
            background: #2868a8;
        }
        #cell-dimensions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 14px;
            line-height: 1.8;
        }
        #cell-dimensions h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function App() {
            const [params, setParams] = useState({
                width: 100,
                depth: 100,
                height: 50,
                thickness: 2,
                bottomHeight: 2,
                vPartitions: 0,
                hPartitions: 0,
                opacity: 0.4,
                fillet: false,
                partitionsExtendToBottom: false
            });

            const canvasRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const boxMeshRef = useRef(null);
            const cameraAngleRef = useRef({ theta: Math.PI / 4, phi: Math.PI / 4 });
            const cameraDistanceRef = useRef(250);

            // Initialize Three.js scene
            useEffect(() => {
                if (!canvasRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(150, 150, 150);
                camera.up.set(0, 0, 1); // Z-axis is up
                camera.lookAt(0, 0, 0);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                canvasRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(100, 100, 50);
                scene.add(directionalLight);

                // Grid on XY plane (Z=0)
                const gridHelper = new THREE.GridHelper(300, 30, 0x888888, 0xcccccc);
                gridHelper.rotation.x = Math.PI / 2; // Rotate to XY plane
                scene.add(gridHelper);

                // Axis helper (X=red, Y=green, Z=blue)
                const axesHelper = new THREE.AxesHelper(150);
                scene.add(axesHelper);

                // Mouse controls
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                const handleMouseDown = (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                };

                const handleMouseMove = (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - previousMousePosition.x;
                        const deltaY = e.clientY - previousMousePosition.y;

                        cameraAngleRef.current.theta -= deltaX * 0.01;
                        cameraAngleRef.current.phi -= deltaY * 0.01;
                        cameraAngleRef.current.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngleRef.current.phi));

                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                };

                const handleMouseUp = () => {
                    isDragging = false;
                };

                const handleWheel = (e) => {
                    e.preventDefault();
                    cameraDistanceRef.current += e.deltaY * 0.1;
                    cameraDistanceRef.current = Math.max(50, Math.min(500, cameraDistanceRef.current));
                };

                renderer.domElement.addEventListener('mousedown', handleMouseDown);
                renderer.domElement.addEventListener('mousemove', handleMouseMove);
                renderer.domElement.addEventListener('mouseup', handleMouseUp);
                renderer.domElement.addEventListener('wheel', handleWheel);

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);

                    const angle = cameraAngleRef.current;
                    const distance = cameraDistanceRef.current;
                    camera.position.x = distance * Math.sin(angle.phi) * Math.cos(angle.theta);
                    camera.position.y = distance * Math.sin(angle.phi) * Math.sin(angle.theta);
                    camera.position.z = distance * Math.cos(angle.phi);
                    camera.lookAt(0, 0, params.height / 2);

                    renderer.render(scene, camera);
                }
                animate();

                // Handle resize
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    renderer.domElement.removeEventListener('mousedown', handleMouseDown);
                    renderer.domElement.removeEventListener('mousemove', handleMouseMove);
                    renderer.domElement.removeEventListener('mouseup', handleMouseUp);
                    renderer.domElement.removeEventListener('wheel', handleWheel);
                    window.removeEventListener('resize', handleResize);
                    renderer.dispose();
                };
            }, []);

            // Update box when params change (with debounce)
            useEffect(() => {
                if (!sceneRef.current) return;

                const timeoutId = setTimeout(() => {
                    // Remove old box
                    if (boxMeshRef.current) {
                        sceneRef.current.remove(boxMeshRef.current);
                    }

                    // Create new box
                    const boxMesh = createBoxGeometry(params);
                    sceneRef.current.add(boxMesh);
                    boxMeshRef.current = boxMesh;
                }, 50); // 50ms debounce

                return () => clearTimeout(timeoutId);
            }, [params]);

            const updateParam = (key, value) => {
                setParams(prev => ({ ...prev, [key]: value }));
            };

            const handleDownload = () => {
                if (!boxMeshRef.current) return;
                exportSTL(boxMeshRef.current, params);
            };

            const cellInfo = calculateCellInfo(params);

            return (
                <>
                    <div id="canvas-container" ref={canvasRef}></div>

                    <div id="controls">
                        <h3>Box Parameters</h3>

                        <div className="control-group">
                            <label>Width: <span className="value-display">{params.width}</span> mm</label>
                            <input type="range" min="20" max="300" value={params.width} step="1"
                                onChange={(e) => updateParam('width', parseFloat(e.target.value))} />
                            <input type="number" min="20" max="300" value={params.width} step="1"
                                onChange={(e) => updateParam('width', parseFloat(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Depth: <span className="value-display">{params.depth}</span> mm</label>
                            <input type="range" min="20" max="300" value={params.depth} step="1"
                                onChange={(e) => updateParam('depth', parseFloat(e.target.value))} />
                            <input type="number" min="20" max="300" value={params.depth} step="1"
                                onChange={(e) => updateParam('depth', parseFloat(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Height: <span className="value-display">{params.height}</span> mm</label>
                            <input type="range" min="10" max="200" value={params.height} step="1"
                                onChange={(e) => updateParam('height', parseFloat(e.target.value))} />
                            <input type="number" min="10" max="200" value={params.height} step="1"
                                onChange={(e) => updateParam('height', parseFloat(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Wall Thickness: <span className="value-display">{params.thickness}</span> mm</label>
                            <input type="range" min="1" max="10" value={params.thickness} step="0.5"
                                onChange={(e) => updateParam('thickness', parseFloat(e.target.value))} />
                            <input type="number" min="1" max="10" value={params.thickness} step="0.5"
                                onChange={(e) => updateParam('thickness', parseFloat(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Bottom Height: <span className="value-display">{params.bottomHeight}</span> mm</label>
                            <input type="range" min="0.5" max="20" value={params.bottomHeight} step="0.5"
                                onChange={(e) => updateParam('bottomHeight', parseFloat(e.target.value))} />
                            <input type="number" min="0.5" max="20" value={params.bottomHeight} step="0.5"
                                onChange={(e) => updateParam('bottomHeight', parseFloat(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>
                                <input type="checkbox" checked={params.fillet}
                                    onChange={(e) => updateParam('fillet', e.target.checked)} />
                                Enable Fillet (1mm)
                            </label>
                        </div>

                        <div className="control-group">
                            <label>
                                <input type="checkbox" checked={params.partitionsExtendToBottom}
                                    onChange={(e) => updateParam('partitionsExtendToBottom', e.target.checked)} />
                                Extend Partitions to Bottom
                            </label>
                        </div>

                        <hr style={{ margin: '20px 0' }} />

                        <h3>Partitions</h3>

                        <div className="control-group">
                            <label>Vertical Partitions: <span className="value-display">{params.vPartitions}</span></label>
                            <input type="range" min="0" max="10" value={params.vPartitions} step="1"
                                onChange={(e) => updateParam('vPartitions', parseFloat(e.target.value))} />
                            <input type="number" min="0" max="10" value={params.vPartitions} step="1"
                                onChange={(e) => updateParam('vPartitions', parseFloat(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Horizontal Partitions: <span className="value-display">{params.hPartitions}</span></label>
                            <input type="range" min="0" max="10" value={params.hPartitions} step="1"
                                onChange={(e) => updateParam('hPartitions', parseFloat(e.target.value))} />
                            <input type="number" min="0" max="10" value={params.hPartitions} step="1"
                                onChange={(e) => updateParam('hPartitions', parseFloat(e.target.value))} />
                        </div>

                        <button id="download-btn" onClick={handleDownload}>Download STL</button>
                    </div>

                    <div id="cell-dimensions">
                        <h3>Cell Dimensions</h3>
                        <div><strong>Internal Height:</strong> {cellInfo.internalHeight.toFixed(1)} mm</div>
                        <div><strong>Cell Width:</strong> {cellInfo.cellWidth.toFixed(1)} mm</div>
                        <div><strong>Cell Depth:</strong> {cellInfo.cellDepth.toFixed(1)} mm</div>
                    </div>
                </>
            );
        }

        // Geometry creation functions
        function createBoxGeometry(params) {
            const group = new THREE.Group();

            const w = params.width;
            const d = params.depth;
            const h = params.height;
            const t = params.thickness;
            const bh = params.bottomHeight;

            const material = new THREE.MeshStandardMaterial({
                color: 0x4a90e2,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: params.opacity,
                depthWrite: true
            });

            const filletRadius = params.fillet ? 1 : 0;

            // Walls
            const frontWall = filletRadius > 0 ? 
                createRoundedBoxYZ(w, h, t, filletRadius) : 
                new THREE.BoxGeometry(w, h, t);
            const frontMesh = new THREE.Mesh(frontWall, material);
            frontMesh.position.set(0, h / 2, d / 2 - t / 2);
            group.add(frontMesh);

            const backWall = filletRadius > 0 ?
                createRoundedBoxYZ(w, h, t, filletRadius) :
                new THREE.BoxGeometry(w, h, t);
            const backMesh = new THREE.Mesh(backWall, material);
            backMesh.position.set(0, h / 2, -d / 2 + t / 2);
            group.add(backMesh);

            const leftWall = filletRadius > 0 ?
                createRoundedBoxYZ(t, h, d - 2 * t, filletRadius) :
                new THREE.BoxGeometry(t, h, d - 2 * t);
            const leftMesh = new THREE.Mesh(leftWall, material);
            leftMesh.position.set(-w / 2 + t / 2, h / 2, 0);
            group.add(leftMesh);

            const rightWall = filletRadius > 0 ?
                createRoundedBoxYZ(t, h, d - 2 * t, filletRadius) :
                new THREE.BoxGeometry(t, h, d - 2 * t);
            const rightMesh = new THREE.Mesh(rightWall, material);
            rightMesh.position.set(w / 2 - t / 2, h / 2, 0);
            group.add(rightMesh);

            // Bottom plate
            const bottomThickness = 2;
            const bottom = filletRadius > 0 ?
                createRoundedBoxXZ(w, bottomThickness, d, filletRadius) :
                new THREE.BoxGeometry(w, bottomThickness, d);
            const bottomMesh = new THREE.Mesh(bottom, material);
            bottomMesh.position.set(0, bh + bottomThickness / 2, 0);
            group.add(bottomMesh);

            // Vertical partitions
            if (params.vPartitions > 0) {
                // Partitions are always 1mm shorter than walls
                // When extendToBottom is OFF: stop at bottom plate top (y = bh + bottomThickness)
                // When extendToBottom is ON: extend to ground (y = 0) up to wall top - 1mm
                const bottomThickness = 2;
                const partitionHeight = params.partitionsExtendToBottom ? h - 1 : h - bh - bottomThickness - 1;
                const partitionYPos = params.partitionsExtendToBottom ? (h - 1) / 2 : bh + bottomThickness + (h - bh - bottomThickness - 1) / 2;
                const internalWidth = w - 2 * t;
                const numCells = params.vPartitions + 1;
                const totalPartitionWidth = params.vPartitions * t;
                const availableSpace = internalWidth - totalPartitionWidth;
                const cellWidth = availableSpace / numCells;
                
                for (let i = 1; i <= params.vPartitions; i++) {
                    const partition = filletRadius > 0 ?
                        createRoundedBoxYZ(t, partitionHeight, d - 2 * t, filletRadius) :
                        new THREE.BoxGeometry(t, partitionHeight, d - 2 * t);
                    const partitionMesh = new THREE.Mesh(partition, material);
                    const xPos = -internalWidth / 2 + (cellWidth + t) * i - t / 2;
                    partitionMesh.position.set(xPos, partitionYPos, 0);
                    group.add(partitionMesh);
                }
            }

            // Horizontal partitions
            if (params.hPartitions > 0) {
                const bottomThickness = 2;
                const partitionHeight = params.partitionsExtendToBottom ? h - 1 : h - bh - bottomThickness - 1;
                const partitionYPos = params.partitionsExtendToBottom ? (h - 1) / 2 : bh + bottomThickness + (h - bh - bottomThickness - 1) / 2;
                const internalDepth = d - 2 * t;
                const numCells = params.hPartitions + 1;
                const totalPartitionDepth = params.hPartitions * t;
                const availableSpace = internalDepth - totalPartitionDepth;
                const cellDepth = availableSpace / numCells;
                
                for (let i = 1; i <= params.hPartitions; i++) {
                    const partition = filletRadius > 0 ?
                        createRoundedBoxYZ(w - 2 * t, partitionHeight, t, filletRadius) :
                        new THREE.BoxGeometry(w - 2 * t, partitionHeight, t);
                    const partitionMesh = new THREE.Mesh(partition, material);
                    const zPos = -internalDepth / 2 + (cellDepth + t) * i - t / 2;
                    partitionMesh.position.set(0, partitionYPos, zPos);
                    group.add(partitionMesh);
                }
            }

            // Dotted line
            if (bh > 0) {
                const lineMaterial = new THREE.LineDashedMaterial({
                    color: 0xff0000,
                    linewidth: 2,
                    dashSize: 3,
                    gapSize: 2
                });

                const internalWidth = w - 2 * t;
                const internalDepth = d - 2 * t;
                const points = [];
                const hw = internalWidth / 2;
                const hd = internalDepth / 2;
                const y = bh;

                points.push(new THREE.Vector3(-hw, y, -hd));
                points.push(new THREE.Vector3(hw, y, -hd));
                points.push(new THREE.Vector3(hw, y, hd));
                points.push(new THREE.Vector3(-hw, y, hd));
                points.push(new THREE.Vector3(-hw, y, -hd));

                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.computeLineDistances();
                group.add(line);
            }

            // Rotate entire group to make Z-axis up (instead of Y-axis)
            group.rotation.x = Math.PI / 2;

            return group;
        }

        function createRoundedBoxYZ(width, height, depth, radius) {
            const r = Math.min(radius, Math.min(width, height, depth) / 2);

            // Create XY profile (width x height), extrude in Z direction (depth)
            const shape = new THREE.Shape();
            const hw = width / 2 - r;
            const hh = height / 2 - r;

            shape.moveTo(-hw, -hh);
            shape.lineTo(hw, -hh);
            shape.quadraticCurveTo(hw + r, -hh, hw + r, -hh + r);
            shape.lineTo(hw + r, hh);
            shape.quadraticCurveTo(hw + r, hh + r, hw, hh + r);
            shape.lineTo(-hw, hh + r);
            shape.quadraticCurveTo(-hw - r, hh + r, -hw - r, hh);
            shape.lineTo(-hw - r, -hh + r);
            shape.quadraticCurveTo(-hw - r, -hh, -hw, -hh);

            const extrudeSettings = {
                depth: depth,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            // Center and move so extrusion is centered along Z axis
            geometry.translate(0, 0, -depth / 2);

            return geometry;
        }

        function createRoundedBoxXZ(width, thickness, depth, radius) {
            const r = Math.min(radius, Math.min(width, depth) / 2);

            // Create XZ profile, extrude in Y direction
            const shape = new THREE.Shape();
            const hw = width / 2 - r;
            const hd = depth / 2 - r;

            shape.moveTo(-hw, -hd);
            shape.lineTo(hw, -hd);
            shape.quadraticCurveTo(hw + r, -hd, hw + r, -hd + r);
            shape.lineTo(hw + r, hd);
            shape.quadraticCurveTo(hw + r, hd + r, hw, hd + r);
            shape.lineTo(-hw, hd + r);
            shape.quadraticCurveTo(-hw - r, hd + r, -hw - r, hd);
            shape.lineTo(-hw - r, -hd + r);
            shape.quadraticCurveTo(-hw - r, -hd, -hw, -hd);

            const extrudeSettings = {
                depth: thickness,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            // Rotate to make it horizontal (XZ plane)
            geometry.rotateX(Math.PI / 2);
            // After rotation, extrusion is along -Y, so translate to center it
            geometry.translate(0, thickness / 2, 0);

            return geometry;
        }

        function calculateCellInfo(params) {
            const t = params.thickness;
            const bh = params.bottomHeight;
            const h = params.height;

            const internalHeight = h - bh - 2;

            const internalWidth = params.width - 2 * t;
            const numVCells = params.vPartitions + 1;
            const totalPartitionWidth = params.vPartitions * t;
            const cellWidth = (internalWidth - totalPartitionWidth) / numVCells;

            const internalDepth = params.depth - 2 * t;
            const numHCells = params.hPartitions + 1;
            const totalPartitionDepth = params.hPartitions * t;
            const cellDepth = (internalDepth - totalPartitionDepth) / numHCells;

            return { internalHeight, cellWidth, cellDepth };
        }

        function exportSTL(boxMesh, params) {
            const exportGroup = new THREE.Group();
            
            // Update world matrix first
            boxMesh.updateMatrixWorld(true);

            boxMesh.traverse((child) => {
                if (child.isMesh) {
                    const geometry = child.geometry.clone();
                    
                    // Apply world matrix to geometry
                    child.updateMatrixWorld();
                    geometry.applyMatrix4(child.matrixWorld);

                    exportGroup.add(new THREE.Mesh(geometry));
                }
            });

            const geometries = [];
            exportGroup.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    geometries.push(child.geometry);
                }
            });

            if (geometries.length === 0) {
                alert('No geometry to export');
                return;
            }

            const mergedGeo = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
            
            // No rotation needed - already in correct orientation (Z-axis up)
            
            const stlString = generateSTL(mergedGeo);

            const blob = new Blob([stlString], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `box_${params.width}x${params.depth}x${params.height}.stl`;
            link.click();
        }

        function generateSTL(geometry) {
            const vertices = geometry.attributes.position;
            const indices = geometry.index;

            let stl = 'solid exported\n';

            if (indices) {
                for (let i = 0; i < indices.count; i += 3) {
                    const i1 = indices.getX(i);
                    const i2 = indices.getX(i + 1);
                    const i3 = indices.getX(i + 2);

                    const v1 = new THREE.Vector3(
                        vertices.getX(i1),
                        vertices.getY(i1),
                        vertices.getZ(i1)
                    );
                    const v2 = new THREE.Vector3(
                        vertices.getX(i2),
                        vertices.getY(i2),
                        vertices.getZ(i2)
                    );
                    const v3 = new THREE.Vector3(
                        vertices.getX(i3),
                        vertices.getY(i3),
                        vertices.getZ(i3)
                    );

                    const cb = new THREE.Vector3();
                    const ab = new THREE.Vector3();
                    cb.subVectors(v3, v2);
                    ab.subVectors(v1, v2);
                    cb.cross(ab);
                    cb.normalize();

                    stl += `  facet normal ${cb.x} ${cb.y} ${cb.z}\n`;
                    stl += '    outer loop\n';
                    stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stl += '    endloop\n';
                    stl += '  endfacet\n';
                }
            } else {
                // Non-indexed geometry
                for (let i = 0; i < vertices.count; i += 3) {
                    const v1 = new THREE.Vector3(
                        vertices.getX(i),
                        vertices.getY(i),
                        vertices.getZ(i)
                    );
                    const v2 = new THREE.Vector3(
                        vertices.getX(i + 1),
                        vertices.getY(i + 1),
                        vertices.getZ(i + 1)
                    );
                    const v3 = new THREE.Vector3(
                        vertices.getX(i + 2),
                        vertices.getY(i + 2),
                        vertices.getZ(i + 2)
                    );

                    const cb = new THREE.Vector3();
                    const ab = new THREE.Vector3();
                    cb.subVectors(v3, v2);
                    ab.subVectors(v1, v2);
                    cb.cross(ab);
                    cb.normalize();

                    stl += `  facet normal ${cb.x} ${cb.y} ${cb.z}\n`;
                    stl += '    outer loop\n';
                    stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stl += '    endloop\n';
                    stl += '  endfacet\n';
                }
            }

            stl += 'endsolid exported\n';
            return stl;
        }

        // Render
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
